

# DuckTyping

El **duck typing** es un concepto muy importante en Python y en lenguajes dinÃ¡micos.

## ğŸ“Œ 1. DefiniciÃ³n

El tÃ©rmino viene de la frase:

> _"If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck."_  
> (â€œSi camina como un pato, nada como un pato y hace cuac como un pato, entonces probablemente sea un patoâ€).


ğŸ‘‰ En programaciÃ³n significa que **lo importante no es el tipo del objeto, sino si tiene los mÃ©todos/atributos necesarios para lo que queremos hacer**.

En otras palabras:

- Python **no revisa de quÃ© clase es un objeto**, solo que pueda comportarse como lo que necesitamos.
    
- Mientras un objeto tenga el **mÃ©todo correcto**, podemos usarlo sin importar de dÃ³nde venga.


```python
class Pato:
    def hablar(self):
        return "Cuac!"

class Persona:
    def hablar(self):
        return "Hola!"

def hacer_hablar(objeto):
    print(objeto.hablar())

# Probamos con ambos
hacer_hablar(Pato())     # Cuac!
hacer_hablar(Persona())  # Hola!

```

> ğŸ‘‰ AquÃ­ `hacer_hablar` no necesita saber si el objeto es un **Pato** o una **Persona**,  
solo necesita que tenga un mÃ©todo `hablar`.



## ğŸ“Œ 4. Ejemplo real con polimorfismo + duck typing


```python
class Perro:
    def sonido(self):
        return "Guau!"

class Auto:
    def sonido(self):
        return "Brrrum!"

def reproducir_sonido(objeto):
    print(objeto.sonido())

# No importa si es animal o mÃ¡quina, ambos "saben" sonar
reproducir_sonido(Perro())  # Guau!
reproducir_sonido(Auto())   # Brrrum!

```


ğŸ‘‰ No hay herencia aquÃ­.  
ğŸ‘‰ Python no se queja de que `Auto` no es un `Animal`.  
ğŸ‘‰ Solo le interesa que tenga un mÃ©todo `sonido`.