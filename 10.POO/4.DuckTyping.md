

# DuckTyping

El **duck typing** es un concepto muy importante en Python y en lenguajes dinámicos.

## 📌 1. Definición

El término viene de la frase:

> _"If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck."_  
> (“Si camina como un pato, nada como un pato y hace cuac como un pato, entonces probablemente sea un pato”).


👉 En programación significa que **lo importante no es el tipo del objeto, sino si tiene los métodos/atributos necesarios para lo que queremos hacer**.

En otras palabras:

- Python **no revisa de qué clase es un objeto**, solo que pueda comportarse como lo que necesitamos.
    
- Mientras un objeto tenga el **método correcto**, podemos usarlo sin importar de dónde venga.


```python
class Pato:
    def hablar(self):
        return "Cuac!"

class Persona:
    def hablar(self):
        return "Hola!"

def hacer_hablar(objeto):
    print(objeto.hablar())

# Probamos con ambos
hacer_hablar(Pato())     # Cuac!
hacer_hablar(Persona())  # Hola!

```

> 👉 Aquí `hacer_hablar` no necesita saber si el objeto es un **Pato** o una **Persona**,  
solo necesita que tenga un método `hablar`.



## 📌 4. Ejemplo real con polimorfismo + duck typing


```python
class Perro:
    def sonido(self):
        return "Guau!"

class Auto:
    def sonido(self):
        return "Brrrum!"

def reproducir_sonido(objeto):
    print(objeto.sonido())

# No importa si es animal o máquina, ambos "saben" sonar
reproducir_sonido(Perro())  # Guau!
reproducir_sonido(Auto())   # Brrrum!

```


👉 No hay herencia aquí.  
👉 Python no se queja de que `Auto` no es un `Animal`.  
👉 Solo le interesa que tenga un método `sonido`.