
# Herencia M√∫ltiple

## üìå 1. ¬øQu√© es la herencia m√∫ltiple?

üëâ Es cuando una clase **hereda de m√°s de una clase padre**.  
En herencia simple ‚Üí `class Hija(Padre): ...`  
En herencia m√∫ltiple ‚Üí `class Hija(Padre1, Padre2): ...`


```python
class Mamifero:
    def amamantar(self):
        return "Soy mam√≠fero y doy leche"

class Acuatico:
    def nadar(self):
        return "Puedo nadar"

class Delfin(Mamifero, Acuatico):
    pass

d = Delfin()
print(d.amamantar())  # Heredado de Mamifero
print(d.nadar())      # Heredado de Acuatico

```


## Mandar llamar directamente las clases padre: 


Aqu√≠ estamos mandando llamar las clases padre y sus respectivos m√©todos

```python
class Cuadrado(FiguraGeometrica, Color):
    def __init__(self, lado, color, ancho, alto):
        #super().__init__(ancho, alto)
        FiguraGeometrica.__init__(self, lado, lado)
        Color.__init__(self, color)

```


## Forma correcta:

_args_ y _kwargs_ almacenan de cierta forma los argumentos y en este caso cuando los mandamos llamar en la clase Cuadrado solo los mandamos llamar en la funci√≥n **calcular_area** ya que los argumentos ya est√°n guardados ah√≠ en  args y kwargs

```python
class FiguraGeometrica:
    def __init__(self, ancho, alto, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.ancho = ancho
        self.alto = alto

class Color:
    def __init__(self, color, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.color = color

class Cuadrado(FiguraGeometrica, Color):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def calcular_area(self):
        return self.alto * self.ancho

```


## Ejemplo 2:

archivo BaseStr:

```python
class BaseStr:
    def __str__(self):
        return ""
```

archivo FiguraGeometrica:

```python
from BaseStr import BaseStr


class FiguraGeometrica(BaseStr):
    def __init__(self, ancho, alto, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._ancho = ancho
        self._alto = alto

    @property
    def ancho(self):
        return self._ancho

    @ancho.setter
    def ancho(self, nuevo_ancho):
        self.ancho = nuevo_ancho

    @property
    def alto(self):
        return self._alto

    @alto.setter
    def alto(self, nuevo_alto):
        self._alto = nuevo_alto

    def __str__(self):

        return f"[Figura: ancho={self._ancho}, alto={self._alto}] " + super().__str__()

```

archivo Color:

```python
from BaseStr import BaseStr

class Color(BaseStr):
    def __init__(self, color, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._color = color

    @property
    def color(self):
        return self._color

    @color.setter
    def color(self, nuevo_color):
         self._color = nuevo_color

    def __str__(self):
        return f"[Color: {self._color}] " + super().__str__()


```

archivo Cuadrado:

```python
# Esta clase heredara de figura geometrcia y de color
from FiguraGeometrica import FiguraGeometrica
from Color import Color

class Cuadrado(FiguraGeometrica, Color):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def calcular_area(self):
        return self._alto * self._ancho

    def __str__(self):
        return f'Cuadrado -> Area: {self.calcular_area()} | ' + super().__str__()
```

archivo Rectangulo:

```python
from FiguraGeometrica import FiguraGeometrica
from Color import Color

class Rectangulo(FiguraGeometrica, Color):
    def __init__(self, *arg, **kwargs):
        super().__init__(*arg, **kwargs)

    def calcularArea(self):
        return self.ancho * self.alto

    def __str__(self):
        return f'Rect√°ngulo -> Area: {self.calcularArea()} | ' + super().__str__()
```


archivo Objetos:

```python
from Color import Color
from Cuadrado import Cuadrado
from FiguraGeometrica import FiguraGeometrica
from Rectangulo import Rectangulo

c1 = Cuadrado(5,4,'Verde')
print(c1)

r1 = Rectangulo(10, 5, 'Amarillo')
print(r1)
```


### üîπ Explicaci√≥n

1. Python empieza buscando m√©todos en **Cuadrado**.
    
2. Si no encuentra el m√©todo, sigue a **FiguraGeometrica**.
    
3. Luego a **Color**.
    
4. Luego a **BaseStr**.
    
5. Finalmente a **object** (pero en `BaseStr` ya cortamos la cadena).


> - ‚úÖ Ventaja: si agregas 5, 6, 7 clases, todas se van sumando sin tocar nada.
    
- ‚úÖ Escalable y limpio ‚Üí solo escribes `super().__str__()` en cada clase.


La clase **BaseStr** nos servir√° para ir concatenando los str de las clases padre y no irlas sobrescribiendo y aplicar el MRO.

- `super().__str__()` sigue el **MRO** y llega a la siguiente clase despu√©s de `Color`.
    
- En nuestro caso, gracias a la clase `BaseStr`, `super().__str__()` devuelve **el string vac√≠o `""`**, porque `BaseStr.__str__()` as√≠ lo define:

	Por eso al final no aparece nada raro de `object` como la direcci√≥n de memoria, solo se concatena lo que t√∫ quieres y si no pues queda vac√≠o como la misma clase lo define.

### üîπ Ventajas de `BaseStr`:

- Cada clase **aporta su parte del string**, sin sobrescribir a las dem√°s.
    
- Funciona autom√°ticamente con herencia m√∫ltiple.
    
- No importa cu√°ntas clases tengas, los `__str__` se **concatenan en el orden del MRO**.
    
- Evita llamar a `object.__str__()` y que salga la direcci√≥n de memoria.