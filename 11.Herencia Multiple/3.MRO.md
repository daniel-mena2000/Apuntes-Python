
# Orden de resolución de métodos (MRO)

Cuando hay herencia múltiple, Python necesita un orden para buscar los métodos.  
Ese orden se llama **MRO (Method Resolution Order)**.

```python
class A:
    def saludo(self): return "Soy A"

class B(A):
    def saludo(self): return "Soy B"

class C(A):
    def saludo(self): return "Soy C"

class D(B, C):  # Hereda de B y C
    pass

d = D()
print(d.saludo())        # ¿Qué imprime?
print(D.__mro__)         # Orden de búsqueda

```

Salida:

```python
Soy B

(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)

```

> 👉 Python busca el método en este orden: `D → B → C → A → object`.


Vamos a desmenuzar ese ejemplo de **herencia múltiple** para que quede **clarísimo** por qué se ejecuta **B** y no **A**.

Python **no sabe de inmediato** de qué clase tomar el método `saludo`.  
Entonces aplica el **MRO (Method Resolution Order)** → el orden en que va buscando métodos.

- Busca en `D`.
    
- Si no está en `D`, busca en `B`.
    
- Si no está en `B`, busca en `C`.
    
- Si no está en `C`, busca en `A`.
    
- Si no está en `A`, busca en `object` (la base de todo en Python).

### 📌 3. ¿Por qué sale "Soy B"?

- Python busca `saludo` en `D`: ❌ no está definido.
    
- Pasa a `B`: ✅ ¡lo encuentra! → `"Soy B"`.
    
- Como ya lo encontró, **no sigue buscando en A ni en C**.


### 📌 4. ¿Qué pasaría si `B` no tuviera `saludo`?

```python
class B(A): 
    pass  # No define saludo
```

- Busca en `D`: ❌
    
- Busca en `B`: ❌
    
- Busca en `C`: ✅ `"Soy C"`
    
- Y ahí se detiene.

### 📌 5. ¿Y si quito también `C.saludo`?

Entonces Python seguiría hasta `A` y ejecutaría `"Soy A"`.



## 📌 4. Uso de `super()` con herencia múltiple

En herencia múltiple, `super()` sigue el **MRO**.  
Esto permite que **todas las clases de la jerarquía participen** sin que se repita el código.

Si usas **`super()`**, Python ya no se queda con la _primera coincidencia_ nada más, sino que **sigue recorriendo el MRO (Method Resolution Order)** y va llamando al siguiente método en la cadena.

```python
class A:
    def accion(self):
        print("Accion A")
        super().accion()

class B:
    def accion(self):
        print("Accion B")
        super().accion()

class C:
    def accion(self):
        print("Accion C")

class D(A, B, C):
    def accion(self):
        print("Accion D")
        super().accion()

d = D()
d.accion()

```
	Salida:
```python
Accion D
Accion A
Accion B
Accion C
```

👉 Python respetó el MRO y fue llamando en cadena con `super()`.


## 📌 . Resumen

- La **herencia múltiple** permite que una clase herede de varias clases padres.
    
- El **MRO** define el orden en que se buscan los métodos.
    
- Con `super()` se puede recorrer toda la jerarquía sin duplicar llamadas.
    
- Puede ser muy útil, pero hay que usarla con cuidado (si hay demasiados padres, se vuelve difícil de entender).