
# Orden de resoluciÃ³n de mÃ©todos (MRO)

Cuando hay herencia mÃºltiple, Python necesita un orden para buscar los mÃ©todos.  
Ese orden se llama **MRO (Method Resolution Order)**.

```python
class A:
    def saludo(self): return "Soy A"

class B(A):
    def saludo(self): return "Soy B"

class C(A):
    def saludo(self): return "Soy C"

class D(B, C):  # Hereda de B y C
    pass

d = D()
print(d.saludo())        # Â¿QuÃ© imprime?
print(D.__mro__)         # Orden de bÃºsqueda

```

Salida:

```python
Soy B

(<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)

```

> ğŸ‘‰ Python busca el mÃ©todo en este orden: `D â†’ B â†’ C â†’ A â†’ object`.


Vamos a desmenuzar ese ejemplo de **herencia mÃºltiple** para que quede **clarÃ­simo** por quÃ© se ejecuta **B** y no **A**.

Python **no sabe de inmediato** de quÃ© clase tomar el mÃ©todo `saludo`.  
Entonces aplica el **MRO (Method Resolution Order)** â†’ el orden en que va buscando mÃ©todos.

- Busca en `D`.
    
- Si no estÃ¡ en `D`, busca en `B`.
    
- Si no estÃ¡ en `B`, busca en `C`.
    
- Si no estÃ¡ en `C`, busca en `A`.
    
- Si no estÃ¡ en `A`, busca en `object` (la base de todo en Python).

### ğŸ“Œ 3. Â¿Por quÃ© sale "Soy B"?

- Python busca `saludo` en `D`: âŒ no estÃ¡ definido.
    
- Pasa a `B`: âœ… Â¡lo encuentra! â†’ `"Soy B"`.
    
- Como ya lo encontrÃ³, **no sigue buscando en A ni en C**.


### ğŸ“Œ 4. Â¿QuÃ© pasarÃ­a si `B` no tuviera `saludo`?

```python
class B(A): 
    pass  # No define saludo
```

- Busca en `D`: âŒ
    
- Busca en `B`: âŒ
    
- Busca en `C`: âœ… `"Soy C"`
    
- Y ahÃ­ se detiene.

### ğŸ“Œ 5. Â¿Y si quito tambiÃ©n `C.saludo`?

Entonces Python seguirÃ­a hasta `A` y ejecutarÃ­a `"Soy A"`.



## ğŸ“Œ 4. Uso de `super()` con herencia mÃºltiple

En herencia mÃºltiple, `super()` sigue el **MRO**.  
Esto permite que **todas las clases de la jerarquÃ­a participen** sin que se repita el cÃ³digo.

Si usas **`super()`**, Python ya no se queda con la _primera coincidencia_ nada mÃ¡s, sino que **sigue recorriendo el MRO (Method Resolution Order)** y va llamando al siguiente mÃ©todo en la cadena.

```python
class A:
    def accion(self):
        print("Accion A")
        super().accion()

class B:
    def accion(self):
        print("Accion B")
        super().accion()

class C:
    def accion(self):
        print("Accion C")

class D(A, B, C):
    def accion(self):
        print("Accion D")
        super().accion()

d = D()
d.accion()

```
	Salida:
```python
Accion D
Accion A
Accion B
Accion C
```

ğŸ‘‰ Python respetÃ³ el MRO y fue llamando en cadena con `super()`.


## ğŸ“Œ . Resumen

- La **herencia mÃºltiple** permite que una clase herede de varias clases padres.
    
- El **MRO** define el orden en que se buscan los mÃ©todos.
    
- Con `super()` se puede recorrer toda la jerarquÃ­a sin duplicar llamadas.
    
- Puede ser muy Ãºtil, pero hay que usarla con cuidado (si hay demasiados padres, se vuelve difÃ­cil de entender).