
# M√©todos de clase y M√©todo est√°tico


## @staticmethod

En Python, `@staticmethod` **no es un m√©todo de clase** como tal, sino un **m√©todo est√°tico**.

La diferencia es importante:

- **M√©todo de instancia**: recibe `self` como primer argumento (puede acceder a atributos y m√©todos del objeto).
    
- **M√©todo de clase**: se define con `@classmethod` y recibe `cls` como primer argumento (puede acceder a la clase y sus atributos de clase).
    
- **M√©todo est√°tico (`@staticmethod`)**: no recibe ni `self` ni `cls`. Es simplemente una funci√≥n **metida dentro de una clase por organizaci√≥n**, pero no tiene acceso directo ni a la instancia ni a la clase.


### üìå ¬øDe qu√© puede depender un m√©todo est√°tico (`@staticmethod`)?

Un m√©todo est√°tico es, b√°sicamente, **una funci√≥n com√∫n que est√° metida dentro de una clase por organizaci√≥n**.

Por eso:

- ‚ùå No puede depender de **atributos de instancia** (porque no recibe `self`).
    
- ‚ùå No puede depender de **atributos de clase** usando `cls` (porque no recibe


```python
class Persona:
    #Atributo de clase
    contador_persona = 0

    def __init__(self, nombre, apellido):

        Persona.contador_persona += 1
        self.id = Persona.contador_persona
        self.nombre = nombre
        self.apellido = apellido

    def mostrar_persona(self): #Metodo de instancia
        print(f'Persona: {self.id}, {self.nombre}, {self.apellido}')

    @staticmethod                #Metodo estatico
    def get_contador_personas_estatico():
        print('Metodo estatico')
        return Persona.contador_persona

if __name__ == '__main__':
    print('Ejemplo Contador de Objetos de tipo Persona')
    persona1 = Persona('Daniel','Marquez')
    persona1.mostrar_persona() #Mandamos llamar el metodo que imprime la informacion

    #Segundo Objeto
    persona2 = Persona('Jose','Perez')
    persona2.mostrar_persona()

    #Imprimiendo el valor del contador de Objetos de personas
    print(f'Numero de Objetos de Persona: {Persona.contador_persona}')
    
    print(f'Numero de Objetos de Persona con metodo estatico: {Persona.get_contador_personas_estatico()}')

```


> En este caso el m√©todo est√°tico de "get_contador_personas_estatico" depende del atributo de clase pero no podr√≠a depender de un m√©todo de instancia o de clase ya que no usa "self" ni "cls"

Tambi√©n puede acceder a lo que tu le pases como argumento:
Ejemplo:

```python
class Calculadora:

    # M√©todo de instancia
    def sumar(self, a, b):
        return a + b

    # M√©todo de clase
    @classmethod
    def info(cls):
        return f"Soy la clase {cls.__name__}"

    # M√©todo est√°tico
    @staticmethod
    def multiplicar(a, b):
        return a * b
```

```python
c = Calculadora()

# M√©todo de instancia -> necesita un objeto
print(c.sumar(2, 3))        # 5

# M√©todo de clase -> puede llamarse desde la clase o el objeto
print(Calculadora.info())   # "Soy la clase Calculadora"
print(c.info())             # "Soy la clase Calculadora"

# M√©todo est√°tico -> no depende de la clase ni del objeto
print(Calculadora.multiplicar(4, 5))  # 20
print(c.multiplicar(4, 5))            # 20
```




## üìå ¬øQu√© es un `@classmethod`?

Un **m√©todo de clase** es aquel que recibe **la clase misma como primer argumento**, en lugar de recibir la instancia.


```python
class Persona:
    #Atributo de clase
    contador_persona = 0

    def __init__(self, nombre, apellido):

        Persona.contador_persona += 1
        self.id = Persona.contador_persona
        self.nombre = nombre
        self.apellido = apellido

    def mostrar_persona(self): #Metodo de instancia
        print(f'Persona: {self.id}, {self.nombre}, {self.apellido}')

    @staticmethod #Metodo estatico
    def get_contador_personas_estatico():
        print('Metodo estatico')
        return Persona.contador_persona

    @classmethod
    def get_contador_personas_clase(cls): #Ya no necesitamos usar el nombre la clase en si mismo ya que tenemos cls
        print('M√©todo de clase')
        return cls.contador_persona

if __name__ == '__main__':
    print('Ejemplo Contador de Objetos de tipo Persona')
    persona1 = Persona('Daniel','Marquez')
    persona1.mostrar_persona() #Mandamos llamar el metodo que imprime la informacion

    #Segundo Objeto
    persona2 = Persona('Jose','Perez')
    persona2.mostrar_persona()

    #Imprimiendo el valor del contador de Objetos de personas
    print(f'Numero de Objetos de Persona: {Persona.contador_persona}')

    print(f'Numero de Objetos de Persona con metodo estatico: {Persona.get_contador_personas_estatico()}')

    print(f'Numero de Objetos de Persona con metodo de clase: {Persona.get_contador_personas_clase()}')

```


>  **s√≠**: a un `@classmethod` se le pueden pasar argumentos igual que a cualquier otra funci√≥n. Lo √∫nico especial es que **el primer argumento siempre es `cls`**, que representa la clase, y luego t√∫ defines los dem√°s par√°metros que quieras.


```python
   def crear_con_nombre_completo(cls, nombre_completo):
```



## ¬øy los cls pueden acceder a los atributos de self??


## üìå Regla general

- Un `@classmethod` recibe `cls`, que representa **la clase**, no una instancia en particular.
    
- Por lo tanto:
    
    - ‚úÖ Puede acceder a **atributos de clase** (`cls.contador_persona`, `cls.otro_atributo`).
        
    - ‚ùå No puede acceder a **atributos de instancia (`self.nombre`, `self.apellido`)**, porque para eso necesitar√≠a un objeto espec√≠fico.


```python
class Persona:
    contador_persona = 0  # atributo de clase

    def __init__(self, nombre, apellido):
        Persona.contador_persona += 1
        self.id = Persona.contador_persona
        self.nombre = nombre      # atributos de instancia
        self.apellido = apellido

    def mostrar_persona(self):
        return f"Persona: {self.id}, {self.nombre}, {self.apellido}"

    @classmethod
    def get_contador(cls):
        return f"Se han creado {cls.contador_persona} personas"

    @classmethod
    def intentar_acceder_a_nombre(cls):
        # ‚ùå Esto dar√≠a error porque cls no tiene 'nombre'
        return cls.nombre
```


